\chapter{مفاهیم بنیادین بلاکچین و اثبات کار}
\label{chap:appendix_basics}

هدف از این پیوست، ارائه یک نمای کلی و فنی از اجزای سازنده یک بلاکچین ساده است. درک این مفاهیم بنیادین، به درک بهتر آسیب‌پذیری‌ها و راهکارهای حریم خصوصی که در بدنه‌ی اصلی گزارش به آن‌ها پرداخته شد، کمک می‌کند. برای ملموس‌تر شدن مفاهیم، از مثال‌هایی مشابه یک پیاده‌سازی ساده با پایتون استفاده خواهیم کرد.

\section{بلاک (\lr{Block}): آجر سازنده زنجیره}

یک بلاکچین، همانطور که از نامش پیداست، زنجیره‌ای از بلاک‌هاست. هر بلاک را می‌توان به عنوان یک صفحه در یک دفتر کل تصور کرد که شامل مجموعه‌ای از اطلاعات است. مهم‌ترین اجزای یک بلاک عبارتند از:
\begin{itemize}
	\item \textbf{فهرست تراکنش‌ها (\lr{Transactions}):} لیستی از تراکنش‌هایی که در این بلاک ثبت شده‌اند.
	\item \textbf{برچسب زمانی (\lr{Timestamp}):} زمان دقیق ایجاد بلاک.
	\item \textbf{هش بلاک قبلی (\lr{Previous Hash}):} مهم‌ترین جزء که امنیت و پیوستگی زنجیره را تضمین می‌کند. این فیلد، هش (اثر انگشت دیجیتال) بلاک قبلی در زنجیره را در خود ذخیره می‌کند.
	\item \textbf{شاخص (\lr{Index}):} شماره ترتیب بلاک در زنجیره.
	\item \textbf{نانس (\lr{Nonce}):} عددی که در فرآیند «اثبات کار» برای یافتن هش معتبر بلاک استفاده می‌شود و در ادامه توضیح داده خواهد شد.
\end{itemize}

تمام این اطلاعات با هم ترکیب شده و از طریق یک تابع هش رمزنگاری (مانند \lr{SHA-256}) به یک رشته منحصربه‌فرد با طول ثابت به نام «هش بلاک» تبدیل می‌شوند. این هش، مانند یک اثر انگشت دیجیتال برای کل بلاک عمل می‌کند. کوچک‌ترین تغییر در هر یک از اطلاعات بالا، منجر به تولید یک هش کاملاً متفاوت خواهد شد.

یک نمایش ساده از ساختار یک بلاک در کد می‌تواند به شکل زیر باشد:
\begin{latin}
	\begin{lstlisting}
		class Block:
		def __init__(self, index, timestamp, transactions, previous_hash):
		self.index = index
		self.timestamp = timestamp
		self.transactions = transactions
		self.previous_hash = previous_hash
		self.nonce = 0  # Nonce starts at 0 for Proof of Work
		self.hash = self.calculate_hash()
		
		def calculate_hash(self):
		# Calculates the hash of the block
		# ... (implementation details)
		pass
	\end{lstlisting}
\end{latin}

\section{زنجیره (\lr{Chain}): اتصال بلاک‌ها به یکدیگر}

امنیت و تغییرناپذیری بلاکچین از نحوه اتصال این بلاک‌ها به یکدیگر ناشی می‌شود. هر بلاک، هش بلاک قبلی خود را در بر دارد. این ساختار، یک زنجیره رمزنگاری‌شده ایجاد می‌کند.
اگر یک مهاجم بخواهد اطلاعات یک تراکنش در یک بلاک قدیمی (مثلاً بلاک شماره ۱۰) را تغییر دهد، این کار باعث تغییر هش بلاک ۱۰ می‌شود. از آنجایی که بلاک ۱۱، هش اصلی بلاک ۱۰ را در خود ذخیره کرده، این پیوند شکسته می‌شود. مهاجم برای معتبرسازی زنجیره، مجبور است هش بلاک ۱۱ را نیز مجدداً محاسبه کند. این فرآیند به صورت آبشاری ادامه پیدا می‌کند و او باید هش تمام بلاک‌های بعدی تا آخرین بلاک را از نو محاسبه کند.

این فرآیند در ترکیب با «اثبات کار»، دستکاری اطلاعات گذشته را از نظر محاسباتی تقریباً غیرممکن می‌سازد. اولین بلاک در هر زنجیره، «بلاک پیدایش» (\lr{Genesis Block}) نام دارد که هیچ هش قبلی ندارد.

\section{اثبات کار (\lr{Proof of Work}): توافق بر سر حقیقت}

در یک شبکه غیرمتمرکز، یک سوال اساسی وجود دارد: چه کسی حق دارد بلاک بعدی را به زنجیره اضافه کند؟ برای جلوگیری از هرج‌ومرج و حملات، شبکه‌هایی مانند بیت‌کوین از یک مکانیزم اجماع به نام «اثبات کار» (\lr{Proof of Work} یا \lr{PoW}) استفاده می‌کنند.

اثبات کار یک «معمای محاسباتی» است که حل کردن آن دشوار و زمان‌بر است، اما تأیید صحت راه‌حل آن برای دیگران بسیار آسان است. در بیت‌کوین، این معما به شکل زیر است:
«آنقدر عدد «نانس» (\lr{Nonce}) را در بلاک تغییر بده و هر بار هش جدید بلاک را محاسبه کن، تا به یک هش دست پیدا کنی که با تعداد مشخصی صفر شروع شود.»

این «تعداد صفرها» همان «سختی شبکه» (\lr{Difficulty}) است. هرچه تعداد صفرهای مورد نیاز بیشتر باشد، یافتن هش معتبر نیز دشوارتر می‌شود. فرآیند یافتن این نانس، «ماینینگ» (\lr{Mining}) نام دارد.
\begin{latin}
	\begin{lstlisting}
		def proof_of_work(self, last_proof):
		# A simple Proof of Work algorithm:
		# - Find a number 'proof' such that hash(last_proof, proof)
		#   contains 4 leading zeroes
		proof = 0
		while self.valid_proof(last_proof, proof) is False:
		proof += 1
		return proof
		
		def valid_proof(self, last_proof, proof):
		# Validates the proof: Does hash(last_proof, proof) 
		# contain 4 leading zeroes?
		guess = f'{last_proof}{proof}'.encode()
		guess_hash = hashlib.sha256(guess).hexdigest()
		return guess_hash[:4] == "0000"
	\end{lstlisting}
\end{latin}
ماینری که زودتر از دیگران موفق به حل این معما شود، حق اضافه کردن بلاک جدید به زنجیره را به دست می‌آورد و به عنوان پاداش، مقداری بیت‌کوین دریافت می‌کند. از آنجایی که این فرآیند به توان محاسباتی و انرژی بسیار زیادی نیاز دارد، تغییر دادن زنجیره (که نیازمند حل مجدد معمای تمام بلاک‌های بعدی است) از نظر اقتصادی برای یک مهاجم به صرفه نخواهد بود.

این سه جزء -- «بلاک‌های حاوی داده»، «زنجیره متصل با هش» و «مکانیزم اجماع اثبات کار» -- با یکدیگر همکاری می‌کنند تا یک دفتر کل توزیع‌شده، امن و تغییرناپذیر را ایجاد کنند که اساس کار ارزهای دیجیتالی مانند بیت‌کوین است.